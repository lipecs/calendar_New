// src/services/formService.js
import axios from 'axios'
import authService from './auth'

const API_URL = `${import.meta.env.VITE_API_URL}/forms`

class FormService {
  constructor() {
    this.setupInterceptors()
  }

  setupInterceptors() {
    // Interceptor para adicionar token de autentica√ß√£o
    axios.interceptors.request.use(
      (config) => {
        const token = authService.getToken()
        if (token) {
          config.headers.Authorization = `Bearer ${token}`
        }
        return config
      },
      (error) => Promise.reject(error)
    )

    // Interceptor para lidar com respostas
    axios.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          authService.logout()
          window.location.href = '/login'
        }
        return Promise.reject(error)
      }
    )
  }

  getAuthHeaders() {
    const token = authService.getToken()
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  }

  // ============ FORMUL√ÅRIOS ============

  // Buscar todos os formul√°rios (para admins)
  async getAllForms() {
    try {
      console.log('üìã Buscando todos os formul√°rios...')
      const response = await axios.get(API_URL, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rios carregados:', response.data?.length || 0)
      return response.data || []
    } catch (error) {
      console.error('‚ùå Erro ao buscar formul√°rios:', error)
      throw error
    }
  }

  // Buscar formul√°rios dispon√≠veis para o usu√°rio atual
  async getAvailableForms() {
    try {
      console.log('üìã Buscando formul√°rios dispon√≠veis...')
      const response = await axios.get(`${API_URL}/available`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rios dispon√≠veis carregados:', response.data?.length || 0)
      return response.data || []
    } catch (error) {
      console.error('‚ùå Erro ao buscar formul√°rios dispon√≠veis:', error)
      throw error
    }
  }

  // Buscar formul√°rio por ID
  async getFormById(formId) {
    try {
      console.log('üìã Buscando formul√°rio por ID:', formId)
      const response = await axios.get(`${API_URL}/${formId}`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rio carregado:', response.data?.title)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao buscar formul√°rio:', error)
      throw error
    }
  }

  // Criar novo formul√°rio
  async createForm(formData) {
    try {
      console.log('‚ûï Criando novo formul√°rio:', formData.title)
      const response = await axios.post(API_URL, formData, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rio criado com sucesso:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao criar formul√°rio:', error)
      throw error
    }
  }

  // Atualizar formul√°rio existente
  async updateForm(formId, formData) {
    try {
      console.log('üìù Atualizando formul√°rio:', formId)
      const response = await axios.put(`${API_URL}/${formId}`, formData, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rio atualizado com sucesso:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao atualizar formul√°rio:', error)
      throw error
    }
  }

  // Excluir formul√°rio
  async deleteForm(formId) {
    try {
      console.log('üóëÔ∏è Excluindo formul√°rio:', formId)
      const response = await axios.delete(`${API_URL}/${formId}`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rio exclu√≠do com sucesso')
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao excluir formul√°rio:', error)
      throw error
    }
  }

  // Duplicar formul√°rio
  async duplicateForm(formId) {
    try {
      console.log('üìã Duplicando formul√°rio:', formId)
      const response = await axios.post(`${API_URL}/${formId}/duplicate`, {}, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Formul√°rio duplicado com sucesso:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao duplicar formul√°rio:', error)
      throw error
    }
  }

  // ============ RESPOSTAS ============

  // Buscar respostas do usu√°rio atual
  async getMyResponses() {
    try {
      console.log('üìù Buscando minhas respostas...')
      const response = await axios.get(`${API_URL}/responses/my`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Respostas carregadas:', response.data?.length || 0)
      return response.data || []
    } catch (error) {
      console.error('‚ùå Erro ao buscar respostas:', error)
      throw error
    }
  }

  // Buscar todas as respostas de um formul√°rio (para admins)
  async getFormResponses(formId) {
    try {
      console.log('üìä Buscando respostas do formul√°rio:', formId)
      const response = await axios.get(`${API_URL}/${formId}/responses`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Respostas do formul√°rio carregadas:', response.data?.length || 0)
      return response.data || []
    } catch (error) {
      console.error('‚ùå Erro ao buscar respostas do formul√°rio:', error)
      throw error
    }
  }

  // Buscar resposta espec√≠fica por ID
  async getResponseById(responseId) {
    try {
      console.log('üìù Buscando resposta por ID:', responseId)
      const response = await axios.get(`${API_URL}/responses/${responseId}`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Resposta carregada:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao buscar resposta:', error)
      throw error
    }
  }

  // Salvar rascunho de resposta
  async saveDraft(responseData) {
    try {
      console.log('üíæ Salvando rascunho da resposta...')
      const response = await axios.post(`${API_URL}/responses/draft`, responseData, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Rascunho salvo com sucesso:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao salvar rascunho:', error)
      throw error
    }
  }

  // Enviar resposta do formul√°rio
  async submitForm(responseData) {
    try {
      console.log('üì§ Enviando resposta do formul√°rio...')
      const response = await axios.post(`${API_URL}/responses`, responseData, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Resposta enviada com sucesso:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao enviar resposta:', error)
      throw error
    }
  }

  // Atualizar resposta existente
  async updateResponse(responseId, responseData) {
    try {
      console.log('üìù Atualizando resposta:', responseId)
      const response = await axios.put(`${API_URL}/responses/${responseId}`, responseData, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Resposta atualizada com sucesso:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao atualizar resposta:', error)
      throw error
    }
  }

  // Excluir resposta
  async deleteResponse(responseId) {
    try {
      console.log('üóëÔ∏è Excluindo resposta:', responseId)
      const response = await axios.delete(`${API_URL}/responses/${responseId}`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Resposta exclu√≠da com sucesso')
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao excluir resposta:', error)
      throw error
    }
  }

  // ============ AN√ÅLISES E RELAT√ìRIOS ============

  // Buscar estat√≠sticas de um formul√°rio
  async getFormStats(formId) {
    try {
      console.log('üìä Buscando estat√≠sticas do formul√°rio:', formId)
      const response = await axios.get(`${API_URL}/${formId}/stats`, {
        headers: this.getAuthHeaders()
      })
      
      console.log('‚úÖ Estat√≠sticas carregadas:', response.data)
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao buscar estat√≠sticas:', error)
      throw error
    }
  }

  // Exportar respostas para Excel
  async exportResponses(formId, format = 'excel') {
    try {
      console.log('üì• Exportando respostas do formul√°rio:', formId)
      const response = await axios.get(`${API_URL}/${formId}/export`, {
        headers: this.getAuthHeaders(),
        params: { format },
        responseType: 'blob'
      })
      
      console.log('‚úÖ Respostas exportadas com sucesso')
      
      // Criar e baixar arquivo
      const blob = new Blob([response.data], { 
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
      })
      const url = window.URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = url
      link.download = `formulario_${formId}_respostas.xlsx`
      link.click()
      window.URL.revokeObjectURL(url)
      
      return response.data
    } catch (error) {
      console.error('‚ùå Erro ao exportar respostas:', error)
      throw error
    }
  }


  // Validar formul√°rio antes de salvar
  validateForm(formData) {
    const errors = []

    // Validar campos obrigat√≥rios
    if (!formData.title?.trim()) {
      errors.push('T√≠tulo √© obrigat√≥rio')
    }

    if (!formData.startDate) {
      errors.push('Data de in√≠cio √© obrigat√≥ria')
    }

    if (!formData.endDate) {
      errors.push('Data de fim √© obrigat√≥ria')
    }

    if (!formData.assignedUsers || formData.assignedUsers.length === 0) {
      errors.push('Selecione pelo menos um usu√°rio')
    }

    if (!formData.sections || formData.sections.length === 0) {
      errors.push('Adicione pelo menos uma se√ß√£o')
    }

    // Validar se√ß√µes
    formData.sections?.forEach((section, sectionIndex) => {
      if (!section.title?.trim()) {
        errors.push(`Se√ß√£o ${sectionIndex + 1}: T√≠tulo √© obrigat√≥rio`)
      }

      if (!section.questions || section.questions.length === 0) {
        errors.push(`Se√ß√£o ${sectionIndex + 1}: Adicione pelo menos uma quest√£o`)
      }

      // Validar quest√µes
      section.questions?.forEach((question, questionIndex) => {
        if (!question.title?.trim()) {
          errors.push(`Se√ß√£o ${sectionIndex + 1}, Quest√£o ${questionIndex + 1}: T√≠tulo √© obrigat√≥rio`)
        }

        if (!question.type) {
          errors.push(`Se√ß√£o ${sectionIndex + 1}, Quest√£o ${questionIndex + 1}: Tipo √© obrigat√≥rio`)
        }

        // Validar op√ß√µes para quest√µes de m√∫ltipla escolha
        if (['multiple', 'single', 'select'].includes(question.type)) {
          if (!question.options || question.options.length === 0) {
            errors.push(`Se√ß√£o ${sectionIndex + 1}, Quest√£o ${questionIndex + 1}: Adicione pelo menos uma op√ß√£o`)
          }

          // Verificar se todas as op√ß√µes est√£o preenchidas
          const emptyOptions = question.options?.filter(option => !option?.trim())
          if (emptyOptions && emptyOptions.length > 0) {
            errors.push(`Se√ß√£o ${sectionIndex + 1}, Quest√£o ${questionIndex + 1}: Todas as op√ß√µes devem ser preenchidas`)
          }
        }
      })
    })

    // Validar datas
    if (formData.startDate && formData.endDate) {
      const startDate = new Date(formData.startDate)
      const endDate = new Date(formData.endDate)
      
      if (startDate >= endDate) {
        errors.push('Data de fim deve ser posterior √† data de in√≠cio')
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    }
  }

  // Validar resposta antes de enviar
  validateResponse(formData, responseData) {
    const errors = []

    // Verificar quest√µes obrigat√≥rias
    formData.sections?.forEach((section, sectionIndex) => {
      section.questions?.forEach((question, questionIndex) => {
        if (question.required) {
          const response = responseData.responses[question.id]
          
          if (response === null || response === undefined || response === '') {
            errors.push(`${section.title} - ${question.title}: Campo obrigat√≥rio`)
          }
          
          // Verificar arrays vazios (m√∫ltipla escolha)
          if (Array.isArray(response) && response.length === 0) {
            errors.push(`${section.title} - ${question.title}: Selecione pelo menos uma op√ß√£o`)
          }
        }
      })
    })

    return {
      isValid: errors.length === 0,
      errors
    }
  }


  // Processar dados do formul√°rio para envio
  processFormData(formData) {
    return {
      ...formData,
      sections: formData.sections?.map(section => ({
        ...section,
        questions: section.questions?.map(question => ({
          ...question,
          options: question.options?.filter(option => option?.trim()) || []
        }))
      }))
    }
  }

  // Gerar ID √∫nico para quest√µes
  generateQuestionId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
  }

  // Calcular progresso da resposta
  calculateProgress(formData, responseData) {
    const totalQuestions = formData.sections?.reduce((total, section) => {
      return total + (section.questions?.length || 0)
    }, 0) || 0

    const answeredQuestions = Object.values(responseData.responses || {}).filter(response => {
      if (Array.isArray(response)) {
        return response.length > 0
      }
      return response !== null && response !== undefined && response !== ''
    }).length
    
    return totalQuestions > 0 ? Math.round((answeredQuestions / totalQuestions) * 100) : 0
  }

  // Formatar data para exibi√ß√£o
  formatDate(dateString) {
    if (!dateString) return '-'
    return new Date(dateString).toLocaleDateString('pt-BR')
  }

  // Formatar data e hora para exibi√ß√£o
  formatDateTime(dateString) {
    if (!dateString) return '-'
    return new Date(dateString).toLocaleString('pt-BR')
  }

  // Verificar se formul√°rio est√° ativo
  isFormActive(form) {
    const now = new Date()
    const startDate = new Date(form.startDate)
    const endDate = new Date(form.endDate)
    
    return now >= startDate && now <= endDate && form.status === 'active'
  }

  // Obter cor do status
  getStatusColor(status) {
    const colors = {
      'active': 'success',
      'inactive': 'secondary',
      'draft': 'warning',
      'completed': 'success',
      'expired': 'error'
    }
    return colors[status] || 'secondary'
  }

  // Obter texto do status
  getStatusText(status) {
    const texts = {
      'active': 'Ativo',
      'inactive': 'Inativo',
      'draft': 'Rascunho',
      'completed': 'Conclu√≠do',
      'expired': 'Expirado'
    }
    return texts[status] || status
  }
}

const formService = new FormService()
export default formService
